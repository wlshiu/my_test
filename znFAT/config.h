#ifndef _CONFIG_H_
#define _CONFIG_H_

/*============================================================================================
  此文件用于对znFAT进行相关配置
=============================================================================================*/

//========= 以下是znFAT的功能函数裁减宏====要使用到哪个功能函数, 请将相应宏的注释去掉 =================

/**
 *  文件系统格式化
 *  此功能涉及ROM数据类型的读写, 请先实现ROM数据的读写, 并保证其稳定正确
 */
//#define ZNFAT_MAKE_FS

/**
 *  刷新文件系统  如果没有使用 RT_UPDATE_FSINFO, 则在所有的文件操作完成之后, 需要调用此函数
 */
#define ZNFAT_FLUSH_FS

/**
 *  打开文件
 */
#define ZNFAT_OPEN_FILE

/**
 *  关闭文件 若无使用 RT_UPDATE_FILESIZE, 则进行文件数据写入删除等操作之后, 
 *  需调用此函数, 否则不调用也没关系
 */
#define ZNFAT_CLOSE_FILE

/**
 *  文件数据读取
 */
#define ZNFAT_READDATA

/**
 *  文件数据读取+重定向 此函数会将读取的每个字节送到处理函数, 处理函数由使用者提供, 请看宏 Data_Redirect
 */
//#define ZNFAT_READDATAX

/**
 *  创建文件
 */
//#define ZNFAT_CREATE_FILE

/**
 *  删除文件
 */
//#define ZNFAT_DELETE_FILE

/**
 *  写入数据, 写入数据均是从文件的末尾追加数据
 */
//#define ZNFAT_WRITEDATA

/**
 *  数据修改
 */
#define ZNFAT_MODIFY_DATA

/**
 *  创建目录, 可以一次性创建多级深层目录
 */
//#define ZNFAT_CREATE_DIR

/**
 *  删除目录, 目录下有子目录和文件, 以及树状子目录结构, 也可一并全部删除
 */
//#define ZNFAT_DELETE_DIR

/**
 *  文件数据截断, 从文件的某个位置之后的数据全部删除
 */
//#define ZNFAT_DUMP_DATA

/**
 *  文件数据定位, 使用者一般用不到, znFAT 已经把它封装到功能函数里
 */
//#define ZNFAT_SEEK

/**
 *  开启 znFAT 的长文件名功能, 在长文件名下需要使用到较多的RAM资源,
 *  可支持的最长文件名长度可由 MAX_LFN_LEN 来定义
 */
//#define USE_LFN

/**
 *  是否会使用OEM字符, 即是否会在长名中出现中文字符
 */
//#define USE_OEM_CHAR

/**
 *  如果一个文件有长名, 则其对应的文件信息集合中的 have_lfn=1, longname 中记录的是
 *  长名的 unicode 码(两个字节表示一个字符), 这里定义的最大长名长度是 unicode 码长
 *  MAX_LFN_LEN 的值请根据实际目标系统的RAM资源来定义, 防止 RAM 溢出
 */
//#define MAX_LFN_LEN   (100)

//============================================================================================

/**
 *  存储设备扇区读写重试次数, 如果次数超过此值,
 *  仍然失败, 则会导致物理设备的IO错误
 */
//#define TOV_CNT   (2)

/**
 *  如果目标平台的 CPU 为 PIC, 则 znFAT 针对其进行了专门处理,
 *  因为PIC中不能直接使用大数组
 */
//#define IS_PIC

/**
 *  使用者是否提供多扇区连续读驱动
 *  多扇区连续读驱动比单纯的单扇区读速度要快, 如果不提供
 *  多扇区连续读驱动, 则znFAT的数据操作性能将比较低
 *  如果此宏被注释, 则程序中默认使用单扇区读方式, 执行效率
 *  可能大打折扣
 */
//#define USE_MULTISEC_R

/**
 *  使用者是否提供多扇区连续写驱动
 *  多扇区连续写驱动比单纯的单扇区写速度要快, 如果不提供
 *  多扇区连续写驱动, 则znFAT的数据操作性能将比较低
 *  如果此宏被注释, 则程序中单扇区写方式, 执行效率可能大打折扣
 */
//#define USE_MULTISEC_W

/**
 *  使用者要提供多扇区连续清0函数
 *  多扇区连续清0, 将应用于格式化中, 会使格式化速度提升
 *  如果此宏被注释, 则程序中默认使用单个扇区逐个清0的方式
 *  执行效率可能会大打折扣
 */
//#define USE_MULTISEC_CLEAR

/**
 *  实时更新FSINFO扇区, 主要是更新剩余簇数, 下一空簇参考值更新没有意义, 因为它本身就不保证一定正确
 *  很多操作系统中获取可用的空簇, 并不以它作为依据, 而是直接扫描整个FAT表。剩余簇数是可以使用的,
 *  用于计算磁盘剩余容量, 如果它的值为0, 则说明磁盘已满, 在znFAT中对其进行了维护
 */
#define RT_UPDATE_FSINFO

/**
 *  实时更新文件信息
 *  以下两个用于“实用更新”的宏如果被注释掉, 则在文件操作结束后, 一定要调用znFAT_Close_File, 否则
 *  磁盘相关信息将不会被更新, 导致虽然向文件写入了数据, 但我们仍然看不到等问题.
 */
#define RT_UPDATE_FILESIZE

//============================================================================================

/**
 *  CCCB, 压缩簇链缓冲, 是znFAT中所使用簇链缓冲算法, 它可以极大的提供数据写入的速度
 *  是否实时更新FAT簇链, 不实时更新, 则使用CCCB簇链缓冲, 可以加快数据写入速度
 */
#define RT_UPDATE_CLUSTER_CHAIN

/**
 *  选择是否使用独立簇链缓冲, 在RAM资源比较充裕的情况下, 这种工作方式下将给每个文件开辟出一个独立的簇链缓冲
 *  与之相对的是共享簇链缓冲（shared CCCB），多个文件同时共享一个簇链缓冲, 会涉及到簇链缓冲的争抢, 效率较alone CCCB
 *  在频繁交替对多个文件进行小数据量写入时, 共享簇链缓冲将起不到什么作用
 */
//#define USE_ALONE_CCCB

#define CCCB_LEN    (8)   //簇链缓冲的长度, 必须为偶数, 且不小于4

//===============================================
/**
 *  EXB, 交换缓冲区, 是znFAT中针对于不足整扇区数据的拼接处理的专用缓冲区, 
 *  可以较大程度上改进因数据拼接导致的效率低下
 */
//#define USE_EXCHANGE_BUFFER

/**
 *  每个文件都有它单独的交换缓冲区, 否则使用共享交换缓冲区
 */
#define USE_ALONE_EXB
//===============================================

/**
 *  数据重定向函数名定义
 */
//#define Data_Redirect     UART_Send_Byte

#endif