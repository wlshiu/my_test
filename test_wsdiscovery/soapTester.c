/* soapTester.c
   Generated by gSOAP 2.8.17r from onvif.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/
/*
   Stand-alone server auto-test code:
   Takes request from standard input or over TCP/IP socket and returns
response to standard output or socket

   Compile:
   cc soapTester.c soapServer.c soapC.c stdsoap2.c

   Command line usage with redirect over stdin/out:
   > ./a.out < SomeTest.req.xml
   > ./a.out 12288 < SomeTest.req.xml
     Note: 12288 = SOAP_XML_INDENT | SOAP_XML_STRICT (see codes in stdsoap2.h)
   Command line usage to start server at port 8080:
   > a.out 12288 8080
*/

#include "wsdd.nsmap"
#include "util.h"
#include "net_util_windows.h"
#include "wsaapi.h"

#ifndef SOAP_DEFMAIN
# define SOAP_DEFMAIN main	/* redefine to use your own main() */
#endif

#ifndef snprintf
    #define snprintf    _snprintf
#endif

static char g_uuid[64] = {0};

int SOAP_DEFMAIN(int argc, char **argv)
{
    char        ip_addr[32] = {0};
	struct soap *soap = soap_new1(SOAP_IO_UDP);

    soap_set_namespaces(soap, namespaces);
    _Get_Host_IP(ip_addr);
    printf("====== ip: %s =====\n", ip_addr);

	if (soap_valid_socket(soap_bind(soap, NULL, 3702, 5)))
    {
        struct ip_mreq  mcast;
        mcast.imr_multiaddr.s_addr = inet_addr("239.255.255.250");
        mcast.imr_interface.s_addr = htonl(INADDR_ANY);
        if( setsockopt(soap->master, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mcast, sizeof(mcast)) < 0 )
        {
            printf("setsockopt error!\n");
            //return -1;
        }

		while (soap_valid_socket(soap_accept(soap)))
		{	soap_serve(soap);
			soap_destroy(soap);
			soap_end(soap);
		}
    }
	soap_free(soap);
	return 0;
}


/** Auto-test server operation SOAP_ENV__Fault */
int SOAP_ENV__Fault(struct soap *soap, char *faultcode, char *faultstring, char *faultactor, struct SOAP_ENV__Detail *detail, struct SOAP_ENV__Code *SOAP_ENV__Code, struct SOAP_ENV__Reason *SOAP_ENV__Reason, char *SOAP_ENV__Node, char *SOAP_ENV__Role, struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{
    enter_trace();
	return SOAP_OK;
}


/** Auto-test server operation __wsdd__Hello */
int __wsdd__Hello(struct soap *soap, struct wsdd__HelloType *wsdd__Hello)
{
    enter_trace();
	return SOAP_OK;
}


/** Auto-test server operation __wsdd__Bye */
int __wsdd__Bye(struct soap *soap, struct wsdd__ByeType *wsdd__Bye)
{
    enter_trace();
	return SOAP_OK;
}


/** Auto-test server operation __wsdd__Probe */
int __wsdd__Probe(struct soap *soap, struct wsdd__ProbeType *wsdd__Probe)
{
    enter_trace();
    do{
        char                            ip_addr[32] = {0};
        char                            mac_addr[13] = {0};
        struct wsdd__ScopesType         *pScopes = NULL;
        char                            str_tmp[256] = {0};
        char scopes_message[] =
            "onvif://www.onvif.org/type/video_encoder\n"
            "onvif://www.onvif.org/name/WL_test\n"
            "onvif://www.onvif.org/hardware/PC\n"
            "onvif://www.onvif.org/location/TW\n"
            "onvif://www.onvif.org/Profile/Streaming\n";

        _Get_Host_IP(ip_addr);
        _Get_MAC_Addr(ip_addr, mac_addr);

        // verify scropes
        if( wsdd__Probe->Scopes && wsdd__Probe->Scopes->__item )
        {
            if( wsdd__Probe->Scopes->MatchBy )
            {
            }
            else
            {
            }
        }

        {// response ProbeMatches
            struct wsdd__ProbeMatchesType   wsdd__ProbeMatches = {0};
            struct wsdd__ProbeMatchType     *pProbeMatchType = NULL;
            struct wsa5__RelatesToType      *pWsa5_RelatesTo = NULL;
            struct wsa__Relationship        *pWsa__RelatesTo = NULL;
            char                            *pMessageID = NULL;

            pProbeMatchType = (struct wsdd__ProbeMatchType*)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType));
            soap_default_wsdd__ProbeMatchType(soap, pProbeMatchType);

            snprintf(str_tmp, 256, "http://%s:%d/onvif/device_service", ip_addr, 8200);
            pProbeMatchType->XAddrs = soap_strdup(soap, str_tmp);
            if( wsdd__Probe->Types && strlen(wsdd__Probe->Types) )
                pProbeMatchType->Types  = soap_strdup(soap, wsdd__Probe->Types);
            else
                pProbeMatchType->Types  = soap_strdup(soap, "dn:NetworkVideoTransmitter");

            pProbeMatchType->MetadataVersion = 1;

            // Build Scopes Message
            pScopes = (struct wsdd__ScopesType *)soap_malloc(soap, sizeof(struct wsdd__ScopesType));
            soap_default_wsdd__ScopesType(soap, pScopes);
            pScopes->MatchBy = soap_strdup(soap, "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01/rfc3986");
            pScopes->__item  = soap_strdup(soap, scopes_message);
            pProbeMatchType->Scopes = pScopes;

            //if( !soap->header->wsa__MessageID || !strlen(soap->header->wsa__MessageID) )
            //    soap->header->wsa__MessageID = soap_wsa_rand_uuid(soap);
            if( !strlen(g_uuid) )
                snprintf(g_uuid, 64, "%s", soap_wsa_rand_uuid(soap));
            pMessageID = g_uuid;
            snprintf(str_tmp, 256, "%s-%s", pMessageID, mac_addr);
            printf("MessageID: %s\n", str_tmp);

            pProbeMatchType->wsa__EndpointReference.Address = soap_strdup(soap, str_tmp);

            wsdd__ProbeMatches.__sizeProbeMatch = 1;
            wsdd__ProbeMatches.ProbeMatch       = pProbeMatchType;

            // Build SOAP Header
            pWsa5_RelatesTo = (struct wsa5__RelatesToType*)soap_malloc(soap, sizeof(struct wsa5__RelatesToType));
            soap_default__wsa5__RelatesTo(soap, pWsa5_RelatesTo);
            pWsa5_RelatesTo->__item = soap->header->wsa__MessageID;
            soap->header->wsa5__RelatesTo = pWsa5_RelatesTo;

            soap->header->wsa5__Action      = soap_strdup(soap, "http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches");
            soap->header->wsa5__To          = soap_strdup(soap, "http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous");

            pWsa__RelatesTo = (struct wsa__Relationship*)soap_malloc(soap, sizeof(struct wsa__Relationship));
            soap_default__wsa__RelatesTo(soap, pWsa__RelatesTo);
            pWsa__RelatesTo->__item = soap->header->wsa__MessageID;
            soap->header->wsa__RelatesTo = pWsa__RelatesTo;

            soap_send___wsdd__ProbeMatches(soap, "http://", NULL, &wsdd__ProbeMatches);
        }
    }while(0);
	return SOAP_OK;
}


/** Auto-test server operation __wsdd__ProbeMatches */
int __wsdd__ProbeMatches(struct soap *soap, struct wsdd__ProbeMatchesType *wsdd__ProbeMatches)
{
    enter_trace();
	return SOAP_OK;
}


/** Auto-test server operation __wsdd__Resolve */
int __wsdd__Resolve(struct soap *soap, struct wsdd__ResolveType *wsdd__Resolve)
{
    enter_trace();
	return SOAP_OK;
}


/** Auto-test server operation __wsdd__ResolveMatches */
int __wsdd__ResolveMatches(struct soap *soap, struct wsdd__ResolveMatchesType *wsdd__ResolveMatches)
{
	return SOAP_OK;
}


/** Auto-test server operation __tdn__Hello */
int __tdn__Hello(struct soap *soap, struct wsdd__HelloType tdn__Hello, struct wsdd__ResolveType *tdn__HelloResponse)
{
	/* Return incomplete response with default data values */
	return SOAP_OK;
}


/** Auto-test server operation __tdn__Bye */
int __tdn__Bye(struct soap *soap, struct wsdd__ByeType tdn__Bye, struct wsdd__ResolveType *tdn__ByeResponse)
{
	/* Return incomplete response with default data values */
	return SOAP_OK;
}


/** Auto-test server operation __tdn__Probe */
int __tdn__Probe(struct soap *soap, struct wsdd__ProbeType tdn__Probe, struct wsdd__ProbeMatchesType *tdn__ProbeResponse)
{
	/* Return incomplete response with default data values */
	return SOAP_OK;
}
